# Meal Helper
#### Video Demo: https://youtu.be/w5F4-z3V4Ao
#### Description:
Meal Helper is a recipe app that emphasizes personalization. The grand idea behind the app was to essentially have an encyclopedia of recipes stored in a database, and to only show users the recipes that pertained to their dietary preferences/needs. That way, users wouldn't have to go searching around the internet for recipes that met their criteria; they could simply open up the app and have plenty of recipes ready to go just for them. It is solely for the iPhone, and although I originally wanted to make an apple watch extension, that would have been too time consuming. The front-end of the app is built with Swift, which I had to learn from scratch for this project, and the back-end is a flask app using Python. It was a good challenge to pick up Swift with no prior knowledge for this project, and I especially had trouble sending and receiving data from Swift, but once I figured it out it was quite rewarding seeing everything work the way I wanted it to.

Moving on to the files for the project, I will start by discussing the files in the Flask-app folder. Meal-Helper.py is the main Python file for this project, and the file in which the flask application runs. There are routes for each of the displayable Swift pages in Meal-Helper.py, each of which returns some sort of data to Swift in json format. Reading the comments in each route will give a much better idea of what each one does. Generally, each route will deal with the mySQL database in some way, whether it is to manipulate rows based on incoming data, or to select data from a table and send it back to Swift. I decided to use mySQL as my database for this project because I wanted some experience working with a server-side SQL database rather than a client-side one like in CS50 Finance. It posed a few more difficulties, but was overall easy to manage when connecting locally from my machine. 

The second file in the Flask-app folder is Meal-Helper-Helper.py, which is where all of the helper functions for Meal-Helper.py are stored, hence the name. The first function in this file is a wrapper that checks whether a user is logged in, and returns a json object indicating a false session value if they are not. The next few functions simply deal with repetitive tasks in Meal-Helper.py. The three that I will mention are queryMaker, mealDicBuilder and preloadRecipes. queryMaker creates SQL AND statements to be inserted after a WHERE clause in a query that gathers all recipes that pertain to a certain user. I thought it was one of my more clever functions, and it is explained deeper in both files. mealDicBuilder is the biggest function in Meal-Helper-Helper.py, and it organizes the data about each recipe gained from the SQL query created by queryMaker into a dictionary that can then be added to a list of all recipe dictionaries and sent to Swift in json format. Finally, preloadRecipes is the most unique function in Meal-Helper-Helper.py since it is the only one not called in Meal-Helper.py. Its purpose is to load the data from recipePreload.json into the recipes table of my database so that the app has some recipes to show without users creating any. This function is only called by running the Meal-Helper-Helper.py file itself.

Onto the Swift files, the first ones that I will mention are Meal-HelperApp.swift, ViewRouter.swift, Motherview.swift, and Helper.swift. These are the files that control which view displays at which time. The published value in the ViewRouter class called currentpage is the value that gets changed every time something happens with the app where the page needs to change. Motherview then communicates the change with Meal-HelperApp, which displays the page indicated by the new currentpage value. I made the decision to change the views in this way because I was new to Swift and I could understand what was happening; however, this method prevented me from adding a tab bar into my app and instead I had to rely solely on navigation links (on the toolbar), so if I could go back I might do a little more research and try to improve the method I used to switch the views. As it is, though, it does the job and doesn't look too bad, so I think it was an acceptable sacrifice to make for a beginner.

Register and Login were the next swift files that I focused on, and the function of these files is very similar to the login and register pages in CS50 Finance. Basically, they take input from the user, and send the data to the register and login routes of Meal-Helper accordingly. For registry, the route checks if the user exists and if their password and confirmation match. If everything checks out, data is sent back to swift telling the page to move on. If not, an error will be displayed on the swift page in red text telling the user what they did wrong. Similarly, the login route checks if the user exists and if their password matches, and then does essentially the same as the register page depending on the data the swift file receives from Meal-Helper.

All files in the Personal Info folder are used for displaying the user's personal information, and the file in the Quizzes folder contains the pages where the user selects their preferences (one page for after registry, one for updating info). When data is submitted via the quiz page, it is sent to the quiz route in Meal-Helper, where it is manipulated as need be and then inserted into the mySQL personal-data table to be called upon later. When the Personal-Info page is requested in Swift, all files in that folder spring into action. The Info-class file represents the format in which swift should expect to receive the personal info data from Python. Then, a variable in the Personal-Info-Helper file can be declared with the same format as the class Info-class. When the Personal Info page is requested, the Personal-Info-Helper file calls to the personal-info route in the Python file, gets the data for the user in the format of the Info-class class, and then passes that data to the Personal-Info file, where it is held in a variable. However, it cannot be displayed yet, and must first be sent to Info-row, which creates list rows out of the data from that variable.

The files in the Recipes folder essentially serve the same purpose for their page as the files in the Personal-Info folder did for theirs. The Meals-class file creates a class that represents the format of the data being received from Python. The Recipes-Helper file then loads the back-end data (dictionary of lists of dictionaries built by mealDicBuilder) into three variables of the class declared in Meals-class. Those variables are then passed to Recipes, where they are unpacked and displayed in a list by Recipes-row. The main difference between this page and the Personal Info page is that the rows of the list are clickable, so more information about each recipe is sent over from Python, and that data is displayed in Recipe-Detail for any given recipe whenever a recipe is clicked on. The RecipeAdder page is much like the quiz page in that it simply accepts data from the user and sends it to the back-end where it is inserted into the mySQL recipes table (if it is valid) so that it can then be shown on the Recipes page.

Finally, I was able to get the app onto my phone through Xcode, and I was able to have my phone communicate with my development server by setting the host of the server to my machine IP and then updating Xcode to send all requests to that address. I changed the addresses in all Xcode files back to localhost for the sake of privacy, but I thought I should mention how I was able to use the app on my phone. That is all I have to say about this project, feel free to read through the files to get a better feel of how things work, and thank you for reading.